---
title: "mcp/migration    1 or 3 intercepts"
author: "David Wolfson"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = F)
```

The point of this html is to show an example of how the mcp package does segmenting swan migration with a completely 'model-driven' approach (i.e., the best model (1-5 intercepts) based just on elpd))

```{r load packages and ggplot source code, message=FALSE, warning=FALSE}
# package names
packages<-c("tidyverse", "here", "mcp", "lubridate", "knitr", "ezknitr", "loo", "flextable")

# install any packages not previously installed
installed_packages<-packages %in% rownames(installed.packages())
if(any(installed_packages == FALSE)){
  install.packages(packages[!installed_packages])
}

# load packages
invisible(lapply(packages, library, character.only = TRUE))
source(here("scripts/ggplot_custom_function.R"))
```


I'll take a couple from a few different categories (easy long, short, resident, etc
 
1) a clearly resident swan (0C_2nd) 

![caption](../../figures/nsd_plots_by_swan/0C_2nd.pdf){width=800px}

2) a 'typical' long-distance migrant (3C)

![](../../figures/nsd_plots_by_swan/3C.pdf){width=800px}

3) a resident with a short foray during the winter (4M)

![](../../figures/nsd_plots_by_swan/4M.pdf){width=800px}

4) a not so clear long-distance migrant with multiple extended winter/spring plateaus (9H_2nd)

![](../../figures/nsd_plots_by_swan/9H_2nd.pdf){width=800px}
 
```{r import dataset}
# This is the entire dataset (n=125) condensed to one record for day with averaged NSD
df<-read_csv(here("data/full_dataset_6_28_2022/full_daily_nsd.csv"))
```

```{r filter dataset}
ids<-c("0C_2nd", "3C", "4M", "9H_2nd")
df<-df %>% 
  filter(id%in%ids)
```

I'm going to split up each swans data by years with July 1 as the cutpoint.

```{r }
df <- df %>%
  group_by(id) %>%
  mutate(swan_yr = ifelse(yday < 182, paste(id, year - 1, year, sep = "-"),
                          paste(id, year, year + 1, sep = "-")
  )) # 182 is julian day for july 1

df$sqrt<-sqrt(df$nsd_daily_mean)
df$rescale<-df$sqrt/1000
```

I'm quickly realizing that a simple 1 vs 3 intercept choice probably would've been better, but I wanted to see what would happen if I gave it up to 5 intercepts to try.
It seems that maybe a strength of mcp is picking out segments, but not necessarily how many should be chosen in the context of migration.
```{r}
# model syntax
one_int<-list(rescale~1)

three_int<-list(rescale~1,
                ~1,
                ~1)

int_mods<-list(one_int, three_int)

prior1_int<-list(int_1="dnorm(0,75)") # resident

prior3_int<-list(int_1 = "int_3")

prior_list<-list(prior1_int, prior3_int)
```

```{r message=FALSE, cache=TRUE}
# fit models
for(i in seq_along(ids)){
  # filter dataset for each swan
  tmp<-df %>% 
    filter(id==ids[[i]])
  
  # filter each "swan-year"
  years<-unique(tmp$swan_yr)
  
  for(j in seq_along(years)){
  tmp_yr<-tmp %>% 
    filter(swan_yr==years[[j]])
  
  # create a numeric index so that dates track chronologically
  tmp_yr$index<-1:nrow(tmp_yr)
  
  # fit mcp models
  out_mods<-list()
  
  for(mm in 1:length(int_mods)){
    out_mods[[mm]]<-mcp(model = int_mods[[mm]], 
                        data = tmp_yr[,c("rescale", "index")],
                        par_x = "index")
  }
  
   for(nn in 1:length(out_mods)){
    out_mods[[nn]]$loo<-loo(out_mods[[nn]])
  }
  
  res<-loo_compare(out_mods[[1]]$loo,
              out_mods[[2]]$loo,
             )
  print(res)
  
  loo_list<-list()
  for(pp in 1:length(int_mods)){
    loo_list[[pp]]<-out_mods[[pp]]$loo$estimates[[1]]
  }
  best_mod<-out_mods[[which.max(loo_list)]]
  print(best_mod)
  p<-plot(best_mod, q_fit=T)+
      ggtitle(glue::glue("The best model for {ids[[i]]} in year {years[[j]]} has {length(best_mod$model)} intercepts"))
  print(p)
  }
}
  
  
  
```









